{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useState as $bBNwq$useState, useRef as $bBNwq$useRef, useCallback as $bBNwq$useCallback } from \"react\";\nfunction $b45bbbaf0c3785df$export$29efd034f1d79f81(props) {\n  var _getItems = props.getItems,\n    collection = props.collection,\n    selectionManager = props.selectionManager,\n    onDragStart = props.onDragStart,\n    onDragMove = props.onDragMove,\n    onDragEnd = props.onDragEnd,\n    preview = props.preview,\n    getAllowedDropOperations = props.getAllowedDropOperations;\n  var _ref = (0, $bBNwq$useState)(false),\n    _ref2 = _slicedToArray(_ref, 2),\n    setDragging = _ref2[1];\n  var draggingKeys = (0, $bBNwq$useRef)(new Set());\n  var draggedKey = (0, $bBNwq$useRef)(null);\n  var getKeys = function getKeys(key) {\n    var keys = new Set(selectionManager.isSelected(key) ? new Set(_toConsumableArray(selectionManager.selectedKeys).filter(function (key) {\n      return !!collection.getItem(key);\n    })) : []);\n    keys.add(key);\n    return keys;\n  };\n  return {\n    collection: collection,\n    selectionManager: selectionManager,\n    get draggedKey() {\n      return draggedKey.current;\n    },\n    get draggingKeys() {\n      return draggingKeys.current;\n    },\n    isDragging: function isDragging(key) {\n      return draggingKeys.current.has(key);\n    },\n    getKeysForDrag: getKeys,\n    getItems: function getItems(key) {\n      return _getItems(getKeys(key));\n    },\n    preview: preview,\n    getAllowedDropOperations: getAllowedDropOperations,\n    startDrag: function startDrag(key, event) {\n      var keys = getKeys(key);\n      draggingKeys.current = keys;\n      draggedKey.current = key;\n      selectionManager.setFocused(false);\n      setDragging(true);\n      if (typeof onDragStart === \"function\") onDragStart(_objectSpread(_objectSpread({}, event), {}, {\n        keys: keys\n      }));\n    },\n    moveDrag: function moveDrag(event) {\n      if (typeof onDragMove === \"function\") onDragMove(_objectSpread(_objectSpread({}, event), {}, {\n        keys: draggingKeys.current\n      }));\n    },\n    endDrag: function endDrag(event) {\n      var isInternal = event.isInternal;\n      if (typeof onDragEnd === \"function\") onDragEnd(_objectSpread(_objectSpread({}, event), {}, {\n        keys: draggingKeys.current,\n        isInternal: isInternal\n      }));\n      draggingKeys.current = new Set();\n      draggedKey.current = null;\n      setDragging(false);\n    }\n  };\n}\nfunction $e672e8bc247525d1$export$926850f6ecef79d0(props) {\n  var _props$acceptedDragTy = props.acceptedDragTypes,\n    acceptedDragTypes = _props$acceptedDragTy === void 0 ? \"all\" : _props$acceptedDragTy,\n    onInsert = props.onInsert,\n    onRootDrop = props.onRootDrop,\n    onItemDrop = props.onItemDrop,\n    onReorder = props.onReorder,\n    shouldAcceptItemDrop = props.shouldAcceptItemDrop,\n    collection = props.collection,\n    selectionManager = props.selectionManager,\n    onDropEnter = props.onDropEnter,\n    getDropOperation = props.getDropOperation,\n    onDrop = props.onDrop;\n  var _ref3 = (0, $bBNwq$useState)(null),\n    _ref4 = _slicedToArray(_ref3, 2),\n    target = _ref4[0],\n    _setTarget = _ref4[1];\n  var targetRef = (0, $bBNwq$useRef)(null);\n  var getOppositeTarget = function getOppositeTarget(target) {\n    if (target.dropPosition === \"before\") {\n      var key = collection.getKeyBefore(target.key);\n      return key != null ? {\n        type: \"item\",\n        key: key,\n        dropPosition: \"after\"\n      } : null;\n    } else if (target.dropPosition === \"after\") {\n      var _key = collection.getKeyAfter(target.key);\n      return _key != null ? {\n        type: \"item\",\n        key: _key,\n        dropPosition: \"before\"\n      } : null;\n    }\n  };\n  var defaultGetDropOperation = (0, $bBNwq$useCallback)(function (e) {\n    var target = e.target,\n      types = e.types,\n      allowedOperations = e.allowedOperations,\n      isInternal = e.isInternal,\n      draggingKeys = e.draggingKeys;\n    if (acceptedDragTypes === \"all\" || acceptedDragTypes.some(function (type) {\n      return types.has(type);\n    })) {\n      var isValidInsert = onInsert && target.type === \"item\" && !isInternal && (target.dropPosition === \"before\" || target.dropPosition === \"after\");\n      var isValidReorder = onReorder && target.type === \"item\" && isInternal && (target.dropPosition === \"before\" || target.dropPosition === \"after\");\n      var isValidRootDrop = onRootDrop && target.type === \"root\" && !isInternal;\n      var isValidOnItemDrop = onItemDrop && target.type === \"item\" && target.dropPosition === \"on\" && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) return getDropOperation(target, types, allowedOperations);else return allowedOperations[0];\n      }\n    }\n    return \"cancel\";\n  }, [acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n  return {\n    collection: collection,\n    selectionManager: selectionManager,\n    target: target,\n    setTarget: function setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) return;\n      var target = targetRef.current;\n      if (target && typeof props.onDropExit === \"function\") props.onDropExit({\n        type: \"dropexit\",\n        x: 0,\n        y: 0,\n        target: target\n      });\n      if (newTarget && typeof onDropEnter === \"function\") onDropEnter({\n        type: \"dropenter\",\n        x: 0,\n        y: 0,\n        target: newTarget\n      });\n      targetRef.current = newTarget;\n      _setTarget(newTarget);\n    },\n    isDropTarget: function isDropTarget(dropTarget) {\n      var target = targetRef.current;\n      if ($e672e8bc247525d1$var$isEqualDropTarget(dropTarget, target)) return true;\n      if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === \"item\" && (target === null || target === void 0 ? void 0 : target.type) === \"item\" && dropTarget.key !== target.key && dropTarget.dropPosition !== target.dropPosition && dropTarget.dropPosition !== \"on\" && target.dropPosition !== \"on\") return $e672e8bc247525d1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target) || $e672e8bc247525d1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      return false;\n    },\n    getDropOperation: function getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\nfunction $e672e8bc247525d1$var$isEqualDropTarget(a, b) {\n  if (!a) return !b;\n  switch (a.type) {\n    case \"root\":\n      return (b === null || b === void 0 ? void 0 : b.type) === \"root\";\n    case \"item\":\n      return (b === null || b === void 0 ? void 0 : b.type) === \"item\" && (b === null || b === void 0 ? void 0 : b.key) === a.key && (b === null || b === void 0 ? void 0 : b.dropPosition) === a.dropPosition;\n  }\n}\nexport { $b45bbbaf0c3785df$export$29efd034f1d79f81 as useDraggableCollectionState, $e672e8bc247525d1$export$926850f6ecef79d0 as useDroppableCollectionState };","map":{"version":3,"names":["$b45bbbaf0c3785df$export$29efd034f1d79f81","props","getItems","collection","selectionManager","onDragStart","onDragMove","onDragEnd","preview","getAllowedDropOperations","_ref","$bBNwq$useState","_ref2","_slicedToArray","setDragging","draggingKeys","$bBNwq$useRef","Set","draggedKey","getKeys","key","keys","isSelected","_toConsumableArray","selectedKeys","filter","getItem","add","current","isDragging","has","getKeysForDrag","startDrag","event","setFocused","_objectSpread","moveDrag","endDrag","isInternal","$e672e8bc247525d1$export$926850f6ecef79d0","_props$acceptedDragTy","acceptedDragTypes","onInsert","onRootDrop","onItemDrop","onReorder","shouldAcceptItemDrop","onDropEnter","getDropOperation","onDrop","_ref3","_ref4","target","setTarget","targetRef","getOppositeTarget","dropPosition","getKeyBefore","type","getKeyAfter","defaultGetDropOperation","$bBNwq$useCallback","e","types","allowedOperations","some","isValidInsert","isValidReorder","isValidRootDrop","isValidOnItemDrop","newTarget","isDropTarget","onDropExit","x","y","dropTarget","$e672e8bc247525d1$var$isEqualDropTarget","a","b"],"sources":["D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\dnd\\dist\\packages\\@react-stately\\dnd\\src\\index.ts","D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\dnd\\dist\\packages\\@react-stately\\dnd\\src\\useDraggableCollectionState.ts","D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\dnd\\dist\\packages\\@react-stately\\dnd\\src\\useDroppableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {DraggableCollectionStateOptions, DraggableCollectionState} from './useDraggableCollectionState';\nexport type {DroppableCollectionStateOptions, DroppableCollectionState} from './useDroppableCollectionState';\nexport {useDraggableCollectionState} from './useDraggableCollectionState';\nexport {useDroppableCollectionState} from './useDroppableCollectionState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DraggableCollectionEndEvent, DraggableCollectionProps, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, Key, Node} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {RefObject, useRef, useState} from 'react';\n\nexport interface DraggableCollectionStateOptions extends DraggableCollectionProps {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager\n}\n\nexport interface DraggableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The key of the item that initiated a drag. */\n  draggedKey: Key | null,\n  /** The keys of the items that are currently being dragged. */\n  draggingKeys: Set<Key>,\n  /** Returns whether the given key is currently being dragged. */\n  isDragging(key: Key): boolean,\n  /** Returns the keys of the items that will be dragged with the given key (e.g. selected items). */\n  getKeysForDrag(key: Key): Set<Key>,\n  /** Returns the items to drag for the given key. */\n  getItems(key: Key): DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /** Begins a drag for the given key. This triggers the onDragStart event. */\n  startDrag(key: Key, event: DragStartEvent): void,\n  /** Triggers an onDragMove event. */\n  moveDrag(event: DragMoveEvent): void,\n  /** Ends the current drag, and emits an onDragEnd event. */\n  endDrag(event: DraggableCollectionEndEvent): void\n}\n\n/**\n * Manages state for a draggable collection.\n */\nexport function useDraggableCollectionState(props: DraggableCollectionStateOptions): DraggableCollectionState {\n  let {\n    getItems,\n    collection,\n    selectionManager,\n    onDragStart,\n    onDragMove,\n    onDragEnd,\n    preview,\n    getAllowedDropOperations\n  } = props;\n  let [, setDragging] = useState(false);\n  let draggingKeys = useRef(new Set<Key>());\n  let draggedKey = useRef(null);\n  let getKeys = (key: Key) => {\n    // The clicked item is always added to the drag. If it is selected, then all of the\n    // other selected items are also dragged. If it is not selected, the only the clicked\n    // item is dragged. This matches native macOS behavior.\n    let keys = new Set(\n      selectionManager.isSelected(key)\n        ? new Set([...selectionManager.selectedKeys].filter(key => !!collection.getItem(key)))\n        : []\n    );\n\n    keys.add(key);\n    return keys;\n  };\n\n  return {\n    collection,\n    selectionManager,\n    get draggedKey() {\n      return draggedKey.current;\n    },\n    get draggingKeys() {\n      return draggingKeys.current;\n    },\n    isDragging(key) {\n      return draggingKeys.current.has(key);\n    },\n    getKeysForDrag: getKeys,\n    getItems(key) {\n      return getItems(getKeys(key));\n    },\n    preview,\n    getAllowedDropOperations,\n    startDrag(key, event) {\n      let keys = getKeys(key);\n      draggingKeys.current = keys;\n      draggedKey.current = key;\n      selectionManager.setFocused(false);\n      setDragging(true);\n      if (typeof onDragStart === 'function') {\n        onDragStart({\n          ...event,\n          keys\n        });\n      }\n    },\n    moveDrag(event) {\n      if (typeof onDragMove === 'function') {\n        onDragMove({\n          ...event,\n          keys: draggingKeys.current\n        });\n      }\n    },\n    endDrag(event) {\n      let {\n        isInternal\n      } = event;\n\n      if (typeof onDragEnd === 'function') {\n        onDragEnd({\n          ...event,\n          keys: draggingKeys.current,\n          isInternal\n        });\n      }\n\n      draggingKeys.current = new Set();\n      draggedKey.current = null;\n      setDragging(false);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DragTypes, DropOperation, DroppableCollectionProps, DropTarget, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCallback, useRef, useState} from 'react';\n\ninterface DropOperationEvent {\n  target: DropTarget,\n  types: DragTypes,\n  allowedOperations: DropOperation[],\n  isInternal: boolean,\n  draggingKeys: Set<Key>\n}\n\nexport interface DroppableCollectionStateOptions extends Omit<DroppableCollectionProps, 'onDropMove' | 'onDropActivate'> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager\n}\n\nexport interface DroppableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The current drop target. */\n  target: DropTarget | null,\n  /** Sets the current drop target. */\n  setTarget(target: DropTarget): void,\n  /** Returns whether the given target is equivalent to the current drop target. */\n  isDropTarget(target: DropTarget): boolean,\n  /** Returns the drop operation for the given parameters. */\n  getDropOperation(e: DropOperationEvent): DropOperation\n}\n\n/**\n * Manages state for a droppable collection.\n */\nexport function useDroppableCollectionState(props: DroppableCollectionStateOptions): DroppableCollectionState  {\n  let {\n    acceptedDragTypes = 'all',\n    onInsert,\n    onRootDrop,\n    onItemDrop,\n    onReorder,\n    shouldAcceptItemDrop,\n    collection,\n    selectionManager,\n    onDropEnter,\n    getDropOperation,\n    onDrop\n  } = props;\n  let [target, setTarget] = useState<DropTarget>(null);\n  let targetRef = useRef<DropTarget>(null);\n\n  let getOppositeTarget = (target: ItemDropTarget): ItemDropTarget => {\n    if (target.dropPosition === 'before') {\n      let key = collection.getKeyBefore(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'after'} : null;\n    } else if (target.dropPosition === 'after') {\n      let key = collection.getKeyAfter(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'before'} : null;\n    }\n  };\n\n  let defaultGetDropOperation = useCallback((e: DropOperationEvent) => {\n    let {\n      target,\n      types,\n      allowedOperations,\n      isInternal,\n      draggingKeys\n    } = e;\n\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder && target.type === 'item' && isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      // Feedback was that internal root drop was weird so preventing that from happening\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      // Automatically prevent items (i.e. folders) from being dropped on themselves.\n      let isValidOnItemDrop = onItemDrop && target.type === 'item' && target.dropPosition === 'on' && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) {\n          return getDropOperation(target, types, allowedOperations);\n        } else {\n          return allowedOperations[0];\n        }\n      }\n    }\n\n    return 'cancel';\n  }, [acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n\n  return {\n    collection,\n    selectionManager,\n    target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) {\n        return;\n      }\n\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') {\n        props.onDropExit({\n          type: 'dropexit',\n          x: 0, // todo\n          y: 0,\n          target\n        });\n      }\n\n      if (newTarget && typeof onDropEnter === 'function') {\n        onDropEnter({\n          type: 'dropenter',\n          x: 0, // todo\n          y: 0,\n          target: newTarget\n        });\n      }\n\n      targetRef.current = newTarget;\n      setTarget(newTarget);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if (isEqualDropTarget(dropTarget, target)) {\n        return true;\n      }\n\n      // Check if the targets point at the same point between two items, one referring before, and the other after.\n      if (\n        dropTarget?.type === 'item' &&\n        target?.type === 'item' &&\n        dropTarget.key !== target.key &&\n        dropTarget.dropPosition !== target.dropPosition &&\n        dropTarget.dropPosition !== 'on' &&\n        target.dropPosition !== 'on'\n      ) {\n        return isEqualDropTarget(getOppositeTarget(dropTarget), target) ||\n          isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      }\n\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\n\nfunction isEqualDropTarget(a: DropTarget, b: DropTarget) {\n  if (!a) {\n    return !b;\n  }\n\n  switch (a.type) {\n    case 'root':\n      return b?.type === 'root';\n    case 'item':\n      return b?.type === 'item' && b?.key === a.key && b?.dropPosition === a.dropPosition;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}