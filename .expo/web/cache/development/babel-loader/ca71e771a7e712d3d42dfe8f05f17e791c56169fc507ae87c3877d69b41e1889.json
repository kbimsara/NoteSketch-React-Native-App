{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useReducer as $d70Aq$useReducer, useRef as $d70Aq$useRef, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  var _options$initialItems = options.initialItems,\n    initialItems = _options$initialItems === void 0 ? [] : _options$initialItems,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey = options.getKey,\n    getKey = _options$getKey === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey,\n    filter = options.filter,\n    _options$initialFilte = options.initialFilterText,\n    initialFilterText = _options$initialFilte === void 0 ? \"\" : _options$initialFilte;\n  var _ref = (0, $d70Aq$useState)({\n      items: initialItems,\n      selectedKeys: initialSelectedKeys === \"all\" ? \"all\" : new Set(initialSelectedKeys || []),\n      filterText: initialFilterText\n    }),\n    _ref2 = _slicedToArray(_ref, 2),\n    state = _ref2[0],\n    setState = _ref2[1];\n  var filteredItems = (0, $d70Aq$useMemo)(function () {\n    return filter ? state.items.filter(function (item) {\n      return filter(item, state.filterText);\n    }) : state.items;\n  }, [state.items, state.filterText, filter]);\n  return _objectSpread(_objectSpread(_objectSpread({}, state), {}, {\n    items: filteredItems\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n    getKey: getKey\n  }, setState)), {}, {\n    getItem: function getItem(key) {\n      return state.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    }\n  });\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  var cursor = opts.cursor,\n    getKey = opts.getKey;\n  return {\n    setSelectedKeys: function setSelectedKeys(selectedKeys) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          selectedKeys: selectedKeys\n        });\n      });\n    },\n    setFilterText: function setFilterText(filterText) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          filterText: filterText\n        });\n      });\n    },\n    insert: function insert(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) {\n          if (state.items.length === 0) index = 0;else return state;\n        }\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertAfter: function insertAfter(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) {\n          if (state.items.length === 0) index = 0;else return state;\n        }\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index + 1].concat(values));\n      });\n    },\n    prepend: function prepend() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, 0].concat(values));\n      });\n    },\n    append: function append() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, state.items.length].concat(values));\n      });\n    },\n    remove: function remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      dispatch(function (state) {\n        var keySet = new Set(keys);\n        var items = state.items.filter(function (item) {\n          return !keySet.has(getKey(item));\n        });\n        var selection = \"all\";\n        if (state.selectedKeys !== \"all\") {\n          selection = new Set(state.selectedKeys);\n          for (var key of keys) selection.delete(key);\n        }\n        if (cursor == null && items.length === 0) selection = new Set();\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: selection\n        });\n      });\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      dispatch(function (state) {\n        if (state.selectedKeys === \"all\") return _objectSpread(_objectSpread({}, state), {}, {\n          items: [],\n          selectedKeys: new Set()\n        });\n        var selectedKeys = state.selectedKeys;\n        var items = state.items.filter(function (item) {\n          return !selectedKeys.has(getKey(item));\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: new Set()\n        });\n      });\n    },\n    move: function move(key, toIndex) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        var copy = state.items.slice();\n        var _copy$splice = copy.splice(index, 1),\n          _copy$splice2 = _slicedToArray(_copy$splice, 1),\n          item = _copy$splice2[0];\n        copy.splice(toIndex, 0, item);\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: copy\n        });\n      });\n    },\n    moveBefore: function moveBefore(key, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (toIndex === -1) return state;\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort(function (a, b) {\n          return a - b;\n        });\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter: function moveAfter(key, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (toIndex === -1) return state;\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort(function (a, b) {\n          return a - b;\n        });\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update: function update(key, newValue) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: [].concat(_toConsumableArray(state.items.slice(0, index)), [newValue], _toConsumableArray(state.items.slice(index + 1)))\n        });\n      });\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index) {\n  for (var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n    values[_key7 - 2] = arguments[_key7];\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: [].concat(_toConsumableArray(state.items.slice(0, index)), values, _toConsumableArray(state.items.slice(index)))\n  });\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  toIndex -= indices.filter(function (index) {\n    return index < toIndex;\n  }).length;\n  var moves = indices.map(function (from) {\n    return {\n      from: from,\n      to: toIndex++\n    };\n  });\n  for (var i = 0; i < moves.length; i++) {\n    var a = moves[i].from;\n    for (var j = i; j < moves.length; j++) {\n      var b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n  for (var _i = 0; _i < moves.length; _i++) {\n    var _a = moves[_i];\n    for (var _j = moves.length - 1; _j > _i; _j--) {\n      var _b = moves[_j];\n      if (_b.from < _a.to) _a.to++;else _b.from++;\n    }\n  }\n  var copy = state.items.slice();\n  for (var move of moves) {\n    var _copy$splice3 = copy.splice(move.from, 1),\n      _copy$splice4 = _slicedToArray(_copy$splice3, 1),\n      item = _copy$splice4[0];\n    copy.splice(move.to, 0, item);\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: copy\n  });\n}\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  var selectedKeys;\n  switch (data.state) {\n    case \"idle\":\n    case \"error\":\n      switch (action.type) {\n        case \"loading\":\n        case \"loadingMore\":\n        case \"sorting\":\n        case \"filtering\":\n          var _action_filterText, _action_sortDescriptor;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText,\n            state: action.type,\n            items: action.type === \"loading\" ? [] : data.items,\n            sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          });\n        case \"update\":\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        case \"success\":\n        case \"error\":\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case \"loading\":\n    case \"sorting\":\n    case \"filtering\":\n      switch (action.type) {\n        case \"success\":\n          if (action.abortController !== data.abortController) return data;\n          var _action_selectedKeys;\n          selectedKeys = (_action_selectedKeys = action.selectedKeys) !== null && _action_selectedKeys !== void 0 ? _action_selectedKeys : data.selectedKeys;\n          var _action_filterText1, _action_sortDescriptor1;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText1 = action.filterText) !== null && _action_filterText1 !== void 0 ? _action_filterText1 : data.filterText,\n            state: \"idle\",\n            items: _toConsumableArray(action.items),\n            selectedKeys: selectedKeys === \"all\" ? \"all\" : new Set(selectedKeys),\n            sortDescriptor: (_action_sortDescriptor1 = action.sortDescriptor) !== null && _action_sortDescriptor1 !== void 0 ? _action_sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case \"error\":\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: \"error\",\n            error: action.error,\n            abortController: null\n          });\n        case \"loading\":\n        case \"loadingMore\":\n        case \"sorting\":\n        case \"filtering\":\n          data.abortController.abort();\n          var _action_filterText2;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText2 = action.filterText) !== null && _action_filterText2 !== void 0 ? _action_filterText2 : data.filterText,\n            state: action.type,\n            items: action.type === \"loading\" ? [] : data.items,\n            abortController: action.abortController\n          });\n        case \"update\":\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case \"loadingMore\":\n      switch (action.type) {\n        case \"success\":\n          var _action_selectedKeys1;\n          selectedKeys = data.selectedKeys === \"all\" || action.selectedKeys === \"all\" ? \"all\" : new Set([].concat(_toConsumableArray(data.selectedKeys), _toConsumableArray((_action_selectedKeys1 = action.selectedKeys) !== null && _action_selectedKeys1 !== void 0 ? _action_selectedKeys1 : [])));\n          var _action_sortDescriptor2;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: \"idle\",\n            items: [].concat(_toConsumableArray(data.items), _toConsumableArray(action.items)),\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_action_sortDescriptor2 = action.sortDescriptor) !== null && _action_sortDescriptor2 !== void 0 ? _action_sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case \"error\":\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: \"error\",\n            error: action.error\n          });\n        case \"loading\":\n        case \"sorting\":\n        case \"filtering\":\n          data.abortController.abort();\n          var _action_filterText3;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_action_filterText3 = action.filterText) !== null && _action_filterText3 !== void 0 ? _action_filterText3 : data.filterText,\n            state: action.type,\n            items: action.type === \"loading\" ? [] : data.items,\n            abortController: action.abortController\n          });\n        case \"loadingMore\":\n          action.abortController.abort();\n          return data;\n        case \"update\":\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  var load = options.load,\n    _sort = options.sort,\n    initialSelectedKeys = options.initialSelectedKeys,\n    initialSortDescriptor = options.initialSortDescriptor,\n    _options$getKey2 = options.getKey,\n    getKey = _options$getKey2 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey2,\n    _options$initialFilte2 = options.initialFilterText,\n    initialFilterText = _options$initialFilte2 === void 0 ? \"\" : _options$initialFilte2;\n  var _ref3 = (0, $d70Aq$useReducer)($f86e6c1ec7da6ebb$var$reducer, {\n      state: \"idle\",\n      error: null,\n      items: [],\n      selectedKeys: initialSelectedKeys === \"all\" ? \"all\" : new Set(initialSelectedKeys),\n      sortDescriptor: initialSortDescriptor,\n      filterText: initialFilterText\n    }),\n    _ref4 = _slicedToArray(_ref3, 2),\n    data = _ref4[0],\n    dispatch = _ref4[1];\n  var dispatchFetch = function () {\n    var _ref5 = _asyncToGenerator(function* (action, fn) {\n      var abortController = new AbortController();\n      try {\n        dispatch(_objectSpread(_objectSpread({}, action), {}, {\n          abortController: abortController\n        }));\n        var _action_filterText;\n        var previousFilterText = (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText;\n        var _action_sortDescriptor;\n        var response = yield fn({\n          items: data.items.slice(),\n          selectedKeys: data.selectedKeys,\n          sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n          signal: abortController.signal,\n          cursor: action.type === \"loadingMore\" ? data.cursor : null,\n          filterText: previousFilterText\n        });\n        var _response_filterText;\n        var filterText = (_response_filterText = response.filterText) !== null && _response_filterText !== void 0 ? _response_filterText : previousFilterText;\n        dispatch(_objectSpread(_objectSpread({\n          type: \"success\"\n        }, response), {}, {\n          abortController: abortController\n        }));\n        if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n          type: \"filtering\",\n          filterText: filterText\n        }, load);\n      } catch (e) {\n        dispatch({\n          type: \"error\",\n          error: e,\n          abortController: abortController\n        });\n      }\n    });\n    return function dispatchFetch(_x, _x2) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var didDispatchInitialFetch = (0, $d70Aq$useRef)(false);\n  (0, $d70Aq$useEffect)(function () {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({\n        type: \"loading\"\n      }, load);\n      didDispatchInitialFetch.current = true;\n    }\n  }, []);\n  return _objectSpread(_objectSpread({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === \"loading\" || data.state === \"loadingMore\" || data.state === \"sorting\" || data.state === \"filtering\",\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem: function getItem(key) {\n      return data.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    },\n    reload: function reload() {\n      dispatchFetch({\n        type: \"loading\"\n      }, load);\n    },\n    loadMore: function loadMore() {\n      if (data.state === \"loadingMore\" || data.state === \"filtering\" || data.cursor == null) return;\n      dispatchFetch({\n        type: \"loadingMore\"\n      }, load);\n    },\n    sort: function sort(sortDescriptor) {\n      dispatchFetch({\n        type: \"sorting\",\n        sortDescriptor: sortDescriptor\n      }, _sort || load);\n    }\n  }, (0, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a)(_objectSpread(_objectSpread({}, options), {}, {\n    getKey: getKey,\n    cursor: data.cursor\n  }), function (fn) {\n    dispatch({\n      type: \"update\",\n      updater: fn\n    });\n  })), {}, {\n    setFilterText: function setFilterText(filterText) {\n      dispatchFetch({\n        type: \"filtering\",\n        filterText: filterText\n      }, load);\n    }\n  });\n}\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  var _options$initialItems2 = options.initialItems,\n    initialItems = _options$initialItems2 === void 0 ? [] : _options$initialItems2,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey3 = options.getKey,\n    getKey = _options$getKey3 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey3,\n    _options$getChildren = options.getChildren,\n    getChildren = _options$getChildren === void 0 ? function (item) {\n      return item.children;\n    } : _options$getChildren;\n  var _ref6 = (0, $d70Aq$useState)(function () {\n      return buildTree(initialItems, new Map());\n    }),\n    _ref7 = _slicedToArray(_ref6, 2),\n    tree = _ref7[0],\n    setItems = _ref7[1];\n  var items = tree.items,\n    nodeMap = tree.nodeMap;\n  var _ref8 = (0, $d70Aq$useState)(new Set(initialSelectedKeys || [])),\n    _ref9 = _slicedToArray(_ref8, 2),\n    selectedKeys = _ref9[0],\n    setSelectedKeys = _ref9[1];\n  function buildTree() {\n    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var map = arguments.length > 1 ? arguments[1] : undefined;\n    var parentKey = arguments.length > 2 ? arguments[2] : undefined;\n    return {\n      items: initialItems.map(function (item) {\n        var node = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n  function updateTree(items, key, update, originalMap) {\n    var node = originalMap.get(key);\n    if (!node) return {\n      items: items,\n      nodeMap: originalMap\n    };\n    var map = new Map(originalMap);\n    var newNode = update(node);\n    if (newNode == null) deleteNode(node, map);else addNode(newNode, map);\n    while (node.parentKey) {\n      var nextParent = map.get(node.parentKey);\n      var copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      var children = nextParent.children;\n      if (newNode == null) children = children.filter(function (c) {\n        return c !== node;\n      });\n      copy.children = children.map(function (child) {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(function (c) {\n      return c !== node;\n    });\n    return {\n      items: items.map(function (item) {\n        if (item === node) return newNode;\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n  function addNode(node, map) {\n    map.set(node.key, node);\n    for (var child of node.children) addNode(child, map);\n  }\n  function deleteNode(node, map) {\n    map.delete(node.key);\n    for (var child of node.children) deleteNode(child, map);\n  }\n  return {\n    items: items,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem: function getItem(key) {\n      return nodeMap.get(key);\n    },\n    insert: function insert(parentKey, index) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        values[_key8 - 2] = arguments[_key8];\n      }\n      setItems(function (_ref10) {\n        var items = _ref10.items,\n          originalMap = _ref10.nodeMap;\n        var _buildTree = buildTree(values, originalMap, parentKey),\n          newNodes = _buildTree.items,\n          newMap = _buildTree.nodeMap;\n        if (parentKey == null) return {\n          items: [].concat(_toConsumableArray(items.slice(0, index)), _toConsumableArray(newNodes), _toConsumableArray(items.slice(index))),\n          nodeMap: newMap\n        };\n        return updateTree(items, parentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(newNodes), _toConsumableArray(parentNode.children.slice(index)))\n          };\n        }, newMap);\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      var node = nodeMap.get(key);\n      if (!node) return;\n      var parentNode = nodeMap.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items;\n      var index = nodes.indexOf(node);\n      for (var _len9 = arguments.length, values = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n        values[_key9 - 1] = arguments[_key9];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index].concat(values));\n    },\n    insertAfter: function insertAfter(key) {\n      var node = nodeMap.get(key);\n      if (!node) return;\n      var parentNode = nodeMap.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items;\n      var index = nodes.indexOf(node);\n      for (var _len10 = arguments.length, values = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n        values[_key10 - 1] = arguments[_key10];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1].concat(values));\n    },\n    prepend: function prepend(parentKey) {\n      for (var _len11 = arguments.length, values = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        values[_key11 - 1] = arguments[_key11];\n      }\n      this.insert.apply(this, [parentKey, 0].concat(values));\n    },\n    append: function append(parentKey) {\n      for (var _len12 = arguments.length, values = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        values[_key12 - 1] = arguments[_key12];\n      }\n      if (parentKey == null) this.insert.apply(this, [null, items.length].concat(values));else {\n        var parentNode = nodeMap.get(parentKey);\n        if (!parentNode) return;\n        this.insert.apply(this, [parentKey, parentNode.children.length].concat(values));\n      }\n    },\n    remove: function remove() {\n      for (var _len13 = arguments.length, keys = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        keys[_key13] = arguments[_key13];\n      }\n      if (keys.length === 0) return;\n      var newItems = items;\n      var prevMap = nodeMap;\n      var newTree;\n      for (var key of keys) {\n        newTree = updateTree(newItems, key, function () {\n          return null;\n        }, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n      setItems(newTree);\n      var selection = new Set(selectedKeys);\n      for (var _key14 of selectedKeys) if (!newTree.nodeMap.has(_key14)) selection.delete(_key14);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      this.remove.apply(this, _toConsumableArray(selectedKeys));\n    },\n    move: function move(key, toParentKey, index) {\n      setItems(function (_ref11) {\n        var items = _ref11.items,\n          originalMap = _ref11.nodeMap;\n        var node = originalMap.get(key);\n        if (!node) return {\n          items: items,\n          nodeMap: originalMap\n        };\n        var _updateTree = updateTree(items, key, function () {\n            return null;\n          }, originalMap),\n          newItems = _updateTree.items,\n          newMap = _updateTree.nodeMap;\n        var movedNode = _objectSpread(_objectSpread({}, node), {}, {\n          parentKey: toParentKey\n        });\n        if (toParentKey == null) return {\n          items: [].concat(_toConsumableArray(newItems.slice(0, index)), [movedNode], _toConsumableArray(newItems.slice(index))),\n          nodeMap: newMap\n        };\n        return updateTree(newItems, toParentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), [movedNode], _toConsumableArray(parentNode.children.slice(index)))\n          };\n        }, newMap);\n      });\n    },\n    update: function update(oldKey, newValue) {\n      setItems(function (_ref12) {\n        var items = _ref12.items,\n          originalMap = _ref12.nodeMap;\n        return updateTree(items, oldKey, function (oldNode) {\n          var node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          var tree = buildTree(getChildren(newValue), originalMap, node.key);\n          node.children = tree.items;\n          return node;\n        }, originalMap);\n      });\n    }\n  };\n}\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData, $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData };","map":{"version":3,"names":["$0d86e9c8f07f9a7b$export$762f73dccccd255d","options","_options$initialItems","initialItems","initialSelectedKeys","_options$getKey","getKey","item","id","key","filter","_options$initialFilte","initialFilterText","_ref","$d70Aq$useState","items","selectedKeys","Set","filterText","_ref2","_slicedToArray","state","setState","filteredItems","$d70Aq$useMemo","_objectSpread","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","getItem","find","opts","dispatch","cursor","setSelectedKeys","setFilterText","insert","index","_len","arguments","length","values","Array","_key","$0d86e9c8f07f9a7b$var$insert","apply","concat","insertBefore","_len2","_key2","findIndex","insertAfter","_len3","_key3","prepend","_len4","_key4","append","_len5","_key5","remove","_len6","keys","_key6","keySet","has","selection","delete","removeSelectedItems","move","toIndex","copy","slice","_copy$splice","splice","_copy$splice2","moveBefore","keyArray","isArray","_toConsumableArray","indices","map","sort","a","b","$0d86e9c8f07f9a7b$var$move","moveAfter","update","newValue","_len7","_key7","moves","from","to","i","j","_copy$splice3","_copy$splice4","$f86e6c1ec7da6ebb$var$reducer","data","action","type","_action_filterText","_action_sortDescriptor","sortDescriptor","abortController","updater","Error","_action_selectedKeys","_action_filterText1","_action_sortDescriptor1","error","abort","_action_filterText2","_action_selectedKeys1","_action_sortDescriptor2","_action_filterText3","$f86e6c1ec7da6ebb$export$bc3384a35de93d66","load","initialSortDescriptor","_options$getKey2","_options$initialFilte2","_ref3","$d70Aq$useReducer","_ref4","dispatchFetch","_ref5","_asyncToGenerator","fn","AbortController","previousFilterText","response","signal","_response_filterText","aborted","e","_x","_x2","didDispatchInitialFetch","$d70Aq$useRef","$d70Aq$useEffect","current","isLoading","loadingState","reload","loadMore","$be2ea0343af54212$export$d14e1352e21f4a16","_options$initialItems2","_options$getKey3","_options$getChildren","getChildren","children","_ref6","buildTree","Map","_ref7","tree","setItems","nodeMap","_ref8","_ref9","undefined","parentKey","node","value","set","updateTree","originalMap","get","newNode","deleteNode","addNode","nextParent","c","child","_len8","_key8","_ref10","_buildTree","newNodes","newMap","parentNode","nodes","indexOf","_len9","_key9","_len10","_key10","_len11","_key11","_len12","_key12","_len13","_key13","newItems","prevMap","newTree","toParentKey","_ref11","_updateTree","movedNode","oldKey","_ref12","oldNode"],"sources":["D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\index.ts","D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useAsyncList.ts","D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useListData.ts","D:\\React Native\\Expo+glustack\\NoteSketch\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useAsyncList} from './useAsyncList';\nexport {useTreeData} from './useTreeData';\nexport {useListData} from './useListData';\n\nexport type {ListOptions, ListData} from './useListData';\nexport type {AsyncListOptions, AsyncListData} from './useAsyncList';\nexport type {TreeOptions, TreeData} from './useTreeData';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, LoadingState, Selection, SortDescriptor} from '@react-types/shared';\nimport {Reducer, useEffect, useReducer, useRef} from 'react';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  let didDispatchInitialFetch = useRef(false);\n  useEffect(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({type: 'loading'}, load);\n      didDispatchInitialFetch.current = true;\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, Selection} from '@react-types/shared';\nimport {useMemo, useState} from 'react';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  toIndex -= indices.filter(index => index < toIndex).length;\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into. `null` for the root.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key | null, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n\n  // We only want to compute this on initial render.\n  let [tree, setItems] = useState<{items: TreeNode<T>[], nodeMap: Map<Key, TreeNode<T>>}>(() => buildTree(initialItems, new Map()));\n  let {items, nodeMap} = tree;\n\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], map: Map<Key, TreeNode<T>>, parentKey?: Key | null) {\n    return {\n      items: initialItems.map(item => {\n        let node: TreeNode<T> = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>, originalMap: Map<Key, TreeNode<T>>) {\n    let node = originalMap.get(key);\n    if (!node) {\n      return {items, nodeMap: originalMap};\n    }\n    let map = new Map<Key, TreeNode<T>>(originalMap);\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node, map);\n    } else {\n      addNode(newNode, map);\n    }\n\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return {\n      items: items.map(item => {\n        if (item === node) {\n          return newNode;\n        }\n\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function addNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child, map);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child, map);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let {items: newNodes, nodeMap: newMap} = buildTree(values, originalMap, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return {\n            items: [\n              ...items.slice(0, index),\n              ...newNodes,\n              ...items.slice(index)\n            ],\n            nodeMap: newMap\n          };\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...newNodes,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      if (keys.length === 0) {\n        return;\n      }\n\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n\n      setItems(newTree);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!newTree.nodeMap.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key | null, index: number) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let node = originalMap.get(key);\n        if (!node) {\n          return {items, nodeMap: originalMap};\n        }\n\n        let {items: newItems, nodeMap: newMap} = updateTree(items, key, () => null, originalMap);\n\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          return {items: [\n            ...newItems.slice(0, index),\n            movedNode,\n            ...newItems.slice(index)\n          ], nodeMap: newMap};\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(({items, nodeMap: originalMap}) => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}